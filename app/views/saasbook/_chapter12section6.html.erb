<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="improving-rendering-and-database-performance-with-caching">
<h1><span class="section-number">12.6. </span>Improving Rendering and Database Performance With Caching<a class="headerlink" href="#improving-rendering-and-database-performance-with-caching" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p><em>There are only two hard things in computer science: cache invalidation and naming things.</em></p>
<p class="attribution">—Phil Karlton</p>
</div></blockquote>

<figure>
  <%= image_tag "Chapter12/12.4.svg", class:"center", alt: "12.4" %>
  <figcaption>
  Figure 12.4: The goal of multiple levels of caching is to satisfy each HTTP request as close to the user as possible. (a) A Web
browser that has previously visited a page can reuse the copy in its local cache after verifying with the server that the page
hasn’t changed. (b) Otherwise, the Web server may be able to serve it from the page cache, bypassing Rails altogether. (c)
Otherwise, if the page is generated by an action protected by a before-filter, Rails may be able to serve it from the action
cache without querying the database or rendering any templates. (d) Otherwise, some of the fragments comprised by the
view templates may be in the fragment cache. (e) As a last resort, the database’s query cache serves the results of recent
queries whose results haven’t changed, such as Movie.all.
  </figcaption>
</figure>

<p>The idea behind caching is simple: information that hasn’t changed since the last time it
was requested can simply be regurgitated rather than recomputed. In SaaS, caching can help
two kinds of computation. First, if information needed from the database to complete an
action hasn’t changed, we can avoid querying the database at all. Second, if the information
underlying a particular view or view fragment hasn’t changed, we can avoid re-rendering the
view (recall that rendering is the process of transforming Erb with embedded Ruby code and
variables into HTML). In any caching scenario, we must address two issues:</p>
<ol class="arabic simple">
<li><p><strong>Naming:</strong> how do we specify that the result of some computation should be cached for later reuse, and name it in a way that ensures it will be used only when that exact same computation is called for?</p></li>
<li><p><strong>Expiration:</strong> How do we detect when the cached version is out of date (stale) because the information on which it depends has changed, and how do we remove it from the cache? The variant of this problem that arises in microprocessor design is often referred to as <em>cache invalidation</em>.</p></li>
</ol>
<p>Figure 12.4 shows how caching can be used at each tier in the 3-tier SaaS architecture and what
Rails entities are cached at each level. The simplest thing we could do is cache the entire HTML
page resulting from rendering a particular controller action. For example, the
<code class="code docutils literal notranslate"><span class="pre">MoviesController#show</span></code> action and its corresponding view depend only on the attributes of the
particular movie being displayed (the <code class="code docutils literal notranslate"><span class="pre">&#64;movie</span></code> variable in the controller method and view
template). Figure 12.5 shows how to cache the entire HTML page for a movie, so
that future requests to that page neither access the database nor re-render the HTML, as
in Figure 12.4(b).</p>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1"># In Gemfile, include gems for page and action caching</span>
<span class="linenos">2</span><span class="n">gem</span> <span class="s1">&#39;actionpack -page_caching&#39;</span>
<span class="linenos">3</span><span class="n">gem</span> <span class="s1">&#39;actionpack -action_caching&#39;</span>
<span class="linenos">4</span><span class="n">gem</span> <span class="s1">&#39;rails-observers&#39;</span>
</pre></div>
</div>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">class</span> <span class="nc">MoviesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
<span class="linenos">2</span>    <span class="n">caches_page</span> <span class="ss">:show</span>
<span class="linenos">3</span>    <span class="n">cache_sweeper</span> <span class="ss">:movie_sweeper</span>
<span class="linenos">4</span>    <span class="k">def</span> <span class="nf">show</span>
<span class="linenos">5</span>        <span class="vi">@movie</span> <span class="o">=</span> <span class="no">Movie</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:id</span><span class="o">]</span><span class="p">)</span>
<span class="linenos">6</span>    <span class="k">end</span>
<span class="linenos">7</span><span class="k">end</span>
</pre></div>
</div>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">class</span> <span class="nc">MovieSweeper</span> <span class="o">&lt;</span> <span class="no">ActionController</span><span class="o">::</span><span class="no">Caching</span><span class="o">::</span><span class="no">Sweeper</span>
<span class="linenos"> 2</span>    <span class="n">observe</span> <span class="no">Movie</span>
<span class="linenos"> 3</span>    <span class="c1"># if a movie is created or deleted, movie list becomes invalid</span>
<span class="linenos"> 4</span>    <span class="c1">#   and rendered partials become invalid</span>
<span class="linenos"> 5</span>    <span class="k">def</span> <span class="nf">after_save</span><span class="p">(</span><span class="n">movie</span><span class="p">)</span>    <span class="p">;</span> <span class="n">invalidate</span> <span class="p">;</span> <span class="k">end</span>
<span class="linenos"> 6</span>    <span class="k">def</span> <span class="nf">after_destroy</span><span class="p">(</span><span class="n">movie</span><span class="p">)</span> <span class="p">;</span> <span class="n">invalidate</span> <span class="p">;</span> <span class="k">end</span>
<span class="linenos"> 7</span>    <span class="kp">private</span>
<span class="linenos"> 8</span>    <span class="k">def</span> <span class="nf">invalidate</span>
<span class="linenos"> 9</span>        <span class="n">expire_action</span> <span class="ss">:action</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;show&#39;</span><span class="o">]</span>
<span class="linenos">10</span>        <span class="n">expire_fragment</span> <span class="s1">&#39;movie&#39;</span>
<span class="linenos">11</span>    <span class="k">end</span>
<span class="linenos">12</span><span class="k">end</span>
</pre></div>
</div>

<figure>
  <figcaption>
  Figure 12.5: (Top) As of Rails 4, caching and observers are provided by separate gems, which must be included in the
Gemfile. (Middle) Line 2 specifies that Rails should cache the result of the show action. Action caching is implemented as a
before-filter that checks whether a cached version should be used and an around-filter that captures and caches the
rendered output, making it an example of the Decorator design pattern (Section 11.4). (Bottom) This “sweeper,” referenced
by line 3 of the controller, uses the Observer design pattern (Section 11.7) to add ActiveRecord lifecycle hooks (Section 5.1)
to expire any objects that might become stale as a result of updating a particular movie.
  </figcaption>
</figure>

<p>Of course, this is unsuitable for controller actions protected by before-filters, such as
pages that require the user to be logged in and therefore require executing the controller
filter. In such cases, changing <code class="code docutils literal notranslate"><span class="pre">caches_page</span></code> to <code class="code docutils literal notranslate"><span class="pre">caches_action</span></code> will still execute any filters
but allow Rails to deliver a cached page without consulting the database or re-rendering
views, as in Figure 12.4(c). Figure 12.7 shows the benefits of page and action caching for
this simple example. Note that in Rails page caching, the name of the cached object <em>ignores</em>
embedded parameters in URIs such as <code class="code docutils literal notranslate"><span class="pre">/movies?ratings=PG+G</span></code>, so parameters that affect how the
page would be displayed should instead be part of the RESTful route, as in <code class="code docutils literal notranslate"><span class="pre">/movies/ratings/</span> <span class="pre">PG+G</span></code>.</p>
<p>An in-between case involves action caching in which the main page content doesn’t change, but
the layout does. For example, your <code class="code docutils literal notranslate"><span class="pre">app/views/layouts/application.html.erb</span></code> may include a message
such as “Welcome, Alice” contain- ing the name of the logged-in user. To allow action caching to
work properly in this case, passing <code class="code docutils literal notranslate"><span class="pre">:layout=&gt;false</span></code> to <code class="code docutils literal notranslate"><span class="pre">caches_action</span></code> will result in the layout
getting fully re-rendered but the action (content part of the page) taking advantage of the
action cache. Keep in mind that since the controller action won’t be run, any such dynamic
content appearing in the layout must be set up in a before-filter.</p>
<p>Page-level caching isn’t useful for pages whose content changes dynamically. For example,
the list of movies page (<code class="code docutils literal notranslate"><span class="pre">MoviesController#index</span></code> action) changes when new movies are added
or when the user filters the list by MPAA rating. But we can still benefit from caching by
observing that the index page consists largely of a collection of table rows, each of which
depends only on the attributes of one specific movie. Indeed, that observation allowed us to
factor out the code for one row into a partial, as Figure 5.1 (Section 5.1) showed. Figure 12.6
shows how a trivial change to that partial caches the rendered HTML fragment corresponding to
each movie.</p>
<div class="highlight-erb notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="cp">&lt;%</span> <span class="n">cache</span><span class="p">(</span><span class="n">movie</span><span class="p">)</span> <span class="k">do</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="linenos">2</span><span class="x">    &lt;div class=&quot;row&quot;&gt;</span>
<span class="linenos">3</span><span class="x">        &lt;div class=&quot;col-8&quot;&gt; </span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="n">movie</span><span class="o">.</span><span class="n">title</span><span class="p">,</span> <span class="n">movie_path</span><span class="p">(</span><span class="n">movie</span><span class="p">)</span> <span class="cp">%&gt;</span><span class="x"> &lt;/div&gt;</span>
<span class="linenos">4</span><span class="x">        &lt;div class=&quot;col-2&quot;&gt; </span><span class="cp">&lt;%=</span> <span class="n">movie</span><span class="o">.</span><span class="n">rating</span> <span class="cp">%&gt;</span><span class="x"> &lt;/div&gt;</span>
<span class="linenos">5</span><span class="x">        &lt;div class=&quot;col-2&quot;&gt; </span><span class="cp">&lt;%=</span> <span class="n">movie</span><span class="o">.</span><span class="n">release_date</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%F&#39;</span><span class="p">)</span> <span class="cp">%&gt;</span><span class="x"> &lt;/div&gt;</span>
<span class="linenos">6</span><span class="x">        &lt;/div&gt;</span>
<span class="linenos">7</span><span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span><span class="x"></span>
</pre></div>
</div>

<figure>
  <figcaption>
  Figure 12.6: Compared to Figure 5.1 in Section 5.1, only two lines have been added, to “wrap” the rendered content with a
call to cache. Rails will generate a name for the cached fragment based on the pluralized resource name and primary key,
for example, movies/23.
  </figcaption>
</figure>

<p>A convenient shortcut provided by Rails is that if the argument to cache is an ActiveRecord
object whose table includes an <code class="code docutils literal notranslate"><span class="pre">updated_at</span></code> or <code class="code docutils literal notranslate"><span class="pre">updated_on</span></code> column, the cache will auto-expire a
fragment if its table row has been updated since the fragment was first cached. Nonetheless,
for clarity, line 10 of the sweeper in Figure 12.5 shows how to explicitly expire a fragment
whose name matches the argument of cache whenever the underlying <code class="code docutils literal notranslate"><span class="pre">movie</span></code> object is saved or
destroyed.</p>
<p>Unlike action caching, which avoids running the controller action at all, checking the fragment
cache occurs <em>after</em> the controller action has run. Given this fact, you may already be wondering
how fragment caching helps reduce the load on the database. For example, suppose we add a partial
to the list of movies page to display the <code class="code docutils literal notranslate"><span class="pre">&#64;top_5</span></code> movies based on
average review scores, and we add a line to the index controller action to set up the variable:</p>
<div class="highlight-erb notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="x">&lt;!-- a cacheable partial for top movies --&gt;</span>
<span class="linenos">2</span><span class="cp">&lt;%-</span> <span class="n">cache</span><span class="p">(</span><span class="s1">&#39;top_moviegoers&#39;</span><span class="p">)</span> <span class="k">do</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="linenos">3</span><span class="x">    &lt;ul id=&quot;topmovies&quot;&gt;</span>
<span class="linenos">4</span><span class="x">        </span><span class="cp">&lt;%-</span> <span class="vi">@top_5</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">movie</span><span class="o">|</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="linenos">5</span><span class="x">        &lt;li&gt; </span><span class="cp">&lt;%=</span> <span class="n">moviegoer</span><span class="o">.</span><span class="n">name</span> <span class="cp">%&gt;</span><span class="x"> &lt;/li&gt;</span>
<span class="linenos">6</span><span class="x">        </span><span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="linenos">7</span><span class="x">    &lt;/ul&gt;</span>
<span class="linenos">8</span><span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span><span class="x"></span>
</pre></div>
</div>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">class</span> <span class="nc">MoviegoersController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
<span class="linenos">2</span>    <span class="k">def</span> <span class="nf">index</span>
<span class="linenos">3</span>        <span class="vi">@movies</span> <span class="o">=</span> <span class="no">Movie</span><span class="o">.</span><span class="n">all</span>
<span class="linenos">4</span>        <span class="vi">@top_5</span> <span class="o">=</span> <span class="no">Movie</span><span class="o">.</span><span class="n">joins</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;movie_id&#39;</span><span class="p">)</span><span class="o">.</span>
<span class="linenos">5</span>            <span class="n">order</span><span class="p">(</span><span class="s2">&quot;AVG(potatoes) DESC&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="linenos">6</span>    <span class="k">end</span>
<span class="linenos">7</span><span class="k">end</span>
</pre></div>
</div>
<p>Action caching is now less useful, because the <code class="code docutils literal notranslate"><span class="pre">index</span></code> view may change when a new movie is
added <em>or</em> when a review is added (which might change what the top 5 reviewed movies are).
If the controller action is run before the fragment cache is checked, aren’t we negating
the benefit of caching, since setting <code class="code docutils literal notranslate"><span class="pre">&#64;top_5</span></code> in lines 4–5 of the controller method causes
a database query?</p>
<p>Surprisingly, no. In fact, lines 4–5 <em>don’t</em> cause a query to happen: they construct an object
that can do the query if it’s ever asked for the result! This is called <strong>lazy evaluation</strong>, an
enormously powerful programming-language technique that comes from the <strong>lambda calculus</strong>
underlying functional programming. Lazy evaluation is used in Rails’ ActiveRelation (ARel)
subsystem, which is used by ActiveRecord. The actual database query doesn’t happen until
each is called in line 4 of of the partial, because that’s the first time the ActiveRelation
object is asked to produce a value. But since that line is inside the <code class="code docutils literal notranslate"><span class="pre">cache</span></code> block starting
on line 2, if the fragment cache hits, the line will never be executed and therefore the
database will never be queried. Of course, you must still include logic in your cache sweeper
to correctly expire the top-5-movies fragment when a new review is added.</p>

<figure>
  <%= image_tag "Chapter12/12.7.jpg", class:"center", alt: "12.7" %>
  <figcaption>
  Figure 12.7: For a PostgreSQL shared database on Heroku containing 1K movies and over 100 reviews per movie, the table
shows the time in milliseconds to retrieve a list of the first 100 reviews sorted by creation date, with and without page and
action caching. The numbers are from the log files visible with heroku logs.
  </figcaption>
</figure>

<p>In summary, both page- and fragment-level caching reward our ability to separate things that
change (non-cacheable units) from those that stay the same (cacheable units). In page or action
caching, split controller actions protected by before-filters into an “unprotected” action that
can use page caching and a filtered action that can use action caching. (In an extreme case,
you can even enlist a <strong>content delivery network</strong> (CDN) such as Amazon CloudFront to replicate the
page at hundreds of servers around the world.) In fragment caching, use partials to isolate each
noncacheable entity, such as a single model instance, into its own partial that can be
fragment-cached.</p>
<p><strong>Self-Check 12.6.1.</strong> <em>We mentioned that passing</em> <code class="code docutils literal notranslate"><span class="pre">:layout=&gt;false</span></code> <em>to</em> <code class="code docutils literal notranslate"><span class="pre">caches_action</span></code>
<em>provides most of the benefit of action caching even when the page layout contains dynamic
elements such as the  logged-in user’s name. Why doesn’t the</em> <code class="code docutils literal notranslate"><span class="pre">caches_page</span></code> <em>method also allow
this option?</em></p>
<blockquote>
<div><p>Since page caching is handled by the presentation tier, not the logic tier, a hit in the page
cache means that Rails is bypassed entirely. The presentation tier has a copy of the whole page,
but only the logic tier knows what part of the page came from the layout and what part came
from rendering the action</p>
</div></blockquote>
</div>


              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="<%= section_path(chapter_id: 12, section_id: 5) %>" title="previous page"><span class="section-number">12.5. </span>Monitoring and Finding Bottlenecks</a>
    <a class='right-next' id="next-link" href="<%= section_path(chapter_id: 12, section_id: 7) %>" title="next page"><span class="section-number">12.7. </span>Avoiding Abusive Database Queries</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By sme777<br/>
        
            &copy; Copyright 2021, Armando Fox and David Patterson.<br/>
      </p>
    </div>
  </footer>
</main>
