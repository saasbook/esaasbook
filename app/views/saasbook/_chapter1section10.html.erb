    
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="guided-tour-and-how-to-use-this-book">
<h1><span class="section-number">1.10. </span>Guided Tour and How To Use This Book<a class="headerlink" href="#guided-tour-and-how-to-use-this-book" title="Permalink to this headline">¶</a></h1>
<p>As this chapter’s Concepts and Prerequisites described, becoming a skilled
software engineer requires <em>both</em> conceptual understanding and plenty of hands-on
practice. Therefore, our goal in each chapter is to give you the necessary conceptual
foundations to work on the exercises, where the real learning happens.</p>
<p>The rest of the book is divided into two parts. Part I explains Software as a Service,
and Part II explains modern software development, with a heavy emphasis on Agile.</p>
<p>Chapter 3 starts Part I with an explanation of the architecture of a SaaS application,
and how the Web went from a collection of static pages to an ecosystem of services
characterized by RESTful APIs—that is, Application Programming Interfaces based on the
design stance of REpresentational State Transfer.</p>
<p>Since languages and frameworks evolve rapidly, we believe <em>learning how to learn</em> new
languages and frameworks is a more valuable skill than knowing a specific language or
framework. Thus, Chapter 2 introduces our methodology for doing so, using Ruby as an
example, for programmers already familiar with another modern language such as Java or Python</p>
<p>Similarly, today the main reason for learning a new language is often the desire to use a
framework that relies on that language. A good framework both reifies a particular application
architecture and takes advantage of the features of a particular language to make
development easy when it conforms to that architecture. Chapter 4 introduces the basics
of Rails and its central metaphor of the Model–View–Controller architecture. Chapter 5 covers
more advanced Rails features and shows in more depth how Rails takes advantage of Ruby’s
language features. Splitting the material this way allows for readers who want to get started
writing an app as soon as they can, which just requires Chapter 4. While the material in
Chapter 5 is more challenging to learn and understand, your application can be DRYer and more
concise if you use concepts like partials, validations, lifecycle callbacks, filters,
associations, and foreign keys. Readers already familiar with Ruby and Rails may want to
skim or skip these chapters.</p>
<p>Building on the familiarity with Ruby and Rails by this point in the book, Chapter 6 introduces
the programming language JavaScript, its productive framework jQuery, and the testing tool Jasmine.
Just as the Rails framework amplifies the power and productivity of the Ruby language for creating
the server side of SaaS apps, the jQuery framework amplifies the power and productivity of JavaScript
for enhancing its client side. And just as RSpec makes it possible to write powerful automated tests
to increase our confidence in our Ruby and Rails code, Jasmine makes it possible to write similar
tests to increase our confidence in our JavaScript code.</p>
<p>Given this background, the next six chapters of Part II illustrate important software engineering
principles using Rails tools to build and deploy a SaaS app. Figure 1.9 shows one iteration of the
Agile lifecycle, which we use as a framework on which to hang the next chapters of the book.</p>
<p>Chapter 7 discusses how to talk to the customer. <strong>Behavior-Driven Design (BDD)</strong> advocates writing
acceptance tests that customers without a programming background can understand, called <strong>user stories</strong>,
and Chapter 7 shows how to write them so that they can be turned into integration tests as well.
It introduces the <strong>Cucumber</strong> tool to help automate this task. This testing tool can be used with any
language and framework, not just Rails. As SaaS apps are often user facing, the chapter also covers
how to prototype a useful user interface using “Lo-Fi” prototyping. It also explains the term <strong>Velocity</strong>
and how to use it to measure progress in the rate that you deliver features, and introduces the SaaS-based
tool <strong>Pivotal Tracker</strong> to track and calculate such measurements.</p>
<p>Chapter 8 covers <strong>Test-Driven Development (TDD)</strong>. The chapter demonstrates how to write good, testable code
and introduces the <strong>RSpec</strong> testing tool for writing unit tests, the <em>Guard</em> tool for automating test running,
and the <em>SimpleCov</em> tool to measure test coverage.</p>
<p>Chapter 9 describes how to deal with existing code, including how to enhance legacy code. Helpfully, it shows
how to use BDD and TDD to both understand and refactor code and how to use the Cucumber and RSpec tools to make
this task easier.</p>
<p>Chapter 10 gives advice on how to organize and work as part of an effective team using the <em>Scrum</em> principles
mentioned above. It also describes how the version control system <strong>Git</strong> and the corresponding service <strong>GitHub</strong> can
let team members work on different features without interfering with each other or causing chaos in the release
process.</p>
<p>To help you practice Don’t Repeat Yourself, Chapter 11 introduces design patterns, which are proven structural
solutions to common problems in designing how classes work together, and shows how to exploit Ruby’s language
features to adopt and reuse the patterns. The chapter also offers guidelines on how to write good classes. It
introduces just enough <em>UML (Unified Modeling Language)</em> notation to help you notate design patterns and to help
you make diagrams that show how the classes should work.</p>
<p>Note that Chapter 11 is about software architecture whereas prior chapters in Part II are
about the Agile development process. We believe in a college course setting that this order will let you start
an Agile iteration sooner, and we think the more iterations you do, the better you will understand the Agile
lifecycle. However, as Figure 1.9 suggests, knowing design patterns will be useful when writing or refactoring
code, since it is fundamental to the BDD/TDD process.</p>
<p>Chapter 12 offers practical advice on how to first deploy and then improve performance and scalability in the
cloud, and briefly introduces some reliability and security techniques that are uniquely relevant to deploying SaaS.</p>
<p>We conclude with an Afterword that reflects on the material in the book and projects what might be next.</p>
<p><strong>CHIPS</strong>. As Confucius said: “I hear and I forget, I see and I remember, I do and I under- stand.” The goal of the
book is to give you just enough content to get a conceptual handle on the Coding/Hands-On Integrated Projects
(CHIPS) interspersed with the text. Each CHIPS exercise contains significant guidance and hints for the
self-learning you’ll have to do to com- plete it. If you’re using this book in conjunction with online course
materials from Codio, switching between the content-oriented didactic material (COD) and the coding/hands-on
integrated projects (CHIPS) is especially easy, and your assignments will be automatically graded for you.</p>
<p><strong>Terminology</strong>. You will encounter many new technical terms (and buzzwords) as you dive into this rich ecosystem.
To help you identify important terms, text formatted <strong>like this</strong> refers to terms with corresponding Wikipedia
entries. (In the Kindle book, PDF document, and Codio book, the terms link to the appropriate Wikipedia page.)
Depending on your background, we suspect you’ll need to read some chapters more than once before you get the hang of it.</p>
<p>Each chapter concludes with a section called <em>Fallacies and Pitfalls</em>, which explains common misconceptions or
problems that are easy to experience if you’re not vigilant, and Concluding Remarks to provide resources for
those who want to dig more deeply into some of the chapter’s concepts.</p>
<p><strong>Self-Check 1.10.1.</strong> <em>Which is most important for rapidly learning SaaS development: understanding the conceptual
foundations, reading code, or writing code?</em></p>
<blockquote>
<div><p>All are important. You won’t learn much by copying-and-pasting code if you don’t un- derstand why it works (or doesn’t).
On the other hand, just reading <em>about</em> code doesn’t get
anything working. Inspecting others’ high-quality code, which we hope your instructors will emphasize, not only shows you
good examples but also helps cement your understanding of the conceptual foundations.</p>
</div></blockquote>
</div>


              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="<%= section_path(chapter_id: 1, section_id: 9) %>" title="previous page"><span class="section-number">1.9. </span>Beautiful vs. Legacy Code</a>
    <a class='right-next' id="next-link" href="<%= section_path(chapter_id: 1, section_id: 11) %>" title="next page"><span class="section-number">1.11. </span>Fallacies and Pitfalls</a>

        </div>
        
        </div>
    </div>
