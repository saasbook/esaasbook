    
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="beautiful-vs-legacy-code">
<h1><span class="section-number">1.9. </span>Beautiful vs. Legacy Code<a class="headerlink" href="#beautiful-vs-legacy-code" title="Permalink to this headline">¶</a></h1>
<p><em>To me programming is more than an important practical art. It is also a gigantic
undertaking in the foundations of knowledge.</em></p>
<blockquote>
<div><p>—Grace Murray Hopper</p>
</div></blockquote>
<p>Unlike hardware, software is expected to grow and evolve over time. Whereas hardware
designs must be declared finished before they can be manufactured and shipped,
initial software designs can easily be shipped and later upgraded over time. Basically,
the cost of upgrade in the field is astronomical for hardware and affordable for software.</p>
<p>Hence, software can achieve a high-tech version of immortality, potentially getting better
over time while generations of computer hardware decay into obsolescence. The drivers of
<strong>software evolution</strong> are not only fixing faults, but also adding new features that customers
request, adjusting to changing business requirements, improving performance, and adapting
to a changed environment. Software customers expect to get notices about and install improved
versions of the software over the lifetime that they use it, perhaps even submitting bug
reports to help developers fix their code. They may even have to pay an annual maintenance
fee for this privilege!</p>
<p>Just as novelists fondly hope that their brainchild will be read long enough to be labeled
a classic—which for books is 100 years!—software engineers should hope their creations would
also be long lasting. Of course, software has the advantage over books of being able to be
improved over time. In fact, a long software life often means that others maintain and enhance
it, letting the creators of original code off the hook.</p>
<p>This brings us to a few terms we’ll use throughout the book. The term <strong>legacy code</strong> refers to
software that, despite its old age, continues to be used because it meets customers’ needs.
Sixty percent of software maintenance costs are for adding new functionality to legacy software,
vs. only 17% for fixing bugs, so legacy software is successful software.</p>
<p>The term “legacy” has a negative connotation, however, in that it indicates that the code is
difficult to evolve because it has an inelegant design or uses antiquated technology. In contrast
to legacy code, we use the term <em>beautiful code</em> to indicate long-lasting code that is easy to
evolve. The worst case is not legacy code, however, but <em>unexpectedly short-lived code</em> that
is soon discarded because it doesn’t meet customers’ needs. We’ll highlight examples that
lead to beautiful code with the Mona Lisa icon. Similarly, we’ll highlight text that deals
with legacy code using an abacus icon, which is certainly a long-lasting but little changed
calculating device.</p>
<p>In the following chapters, we show examples of both beautiful code and legacy code that we hope
will inspire you to make your designs simpler to evolve. Surprisingly, despite the widely accepted
importance of enhancing legacy software, this topic is traditionally ignored in college courses and
textbooks. We feature such software in this book for three reasons. First, you can reduce the effort
to build a program by finding existing code that you can reuse. One supplier is open source software.
Second, it’s advantageous to learn how to build code that makes it easier for successors to enhance,
since such code is more likely to enjoy a long life. Finally, unlike Plan-and-Document, in Agile you
revise code continuously to improve the design and to add functionality starting with the second
iteration. Thus, the skills you practice in Agile are exactly the ones you need to evolve legacy
code—no matter how it was created—and the dual use of Agile techniques makes it much easier for us
to cover legacy code within a single book.</p>

<figure>
    <%= image_tag "Chapter1/1.9.jpg", class:"center", alt: "1.9" %>
    <figcaption>
    Figure 1.9: An iteration of the Agile software lifecycle and its relationship to the chapters in Part II of this book. The dashed
arrows indicate a more tangential relationship between the steps of an iteration, while the solid arrows indicate the typical
flow. As mentioned earlier, the Agile process applies equally well to legacy applications and new applications.
    </figcaption>
</figure>

<p><strong>Self-Check 1.9.1.</strong> <em>Programmers rarely set out to write bad code. Given the ideas of Section 1.5 about
productivity, explain briefly how software written a long time ago that was considered high quality at
the time might be viewed as difficult-to-maintain legacy software today.</em></p>
<blockquote>
<div><p>Because of the continuously increasing level of abstraction of software tools, developers today can often
create the same functionality in far fewer (and more beautiful) lines of code
than would have been possible a few decades ago, so by comparison the old code is harder to maintain,
even though at the time it was written it may have represented the state of the art. Doubtless the code
we write today will be viewed as archaic in another few decades!</p>
</div></blockquote>
</div>


              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="<%= section_path(chapter_id: 1, section_id: 8) %>" title="previous page"><span class="section-number">1.8. </span>Deploying SaaS: Browsers and Mobile</a>
    <a class='right-next' id="next-link" href="<%= section_path(chapter_id: 1, section_id: 10) %>" title="next page"><span class="section-number">1.10. </span>Guided Tour and How To Use This Book</a>

        </div>
        
        </div>
    </div>
